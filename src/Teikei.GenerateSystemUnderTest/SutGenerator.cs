using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Teikei.GenerateSystemUnderTest;

[Generator]
public class InterfacedGenerator : IIncrementalGenerator
{
	private const string AttributeName = "GenerateSut";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var xs = context
			.SyntaxProvider.CreateSyntaxProvider(IsMatchingAttribute, Transform)
			.WithValue()
			.Collect();

		context.RegisterSourceOutput(xs, GeneratePartial);
	}

	private void GeneratePartial(
		SourceProductionContext context,
		ImmutableArray<IMethodSymbol> symbols
	)
	{
		foreach (var methodSymbol in symbols)
		{
			var attribute = methodSymbol
				.GetAttributes()
				.FirstOrDefault(x => x.AttributeClass?.Name is $"{AttributeName}Attribute");
			if (attribute is null)
				continue;

			TypeDeclarationSyntax partialDeclarationSyntax =
				methodSymbol.ContainingType.CreatePartialDeclaration();

			var sutType = methodSymbol.ReturnType;

			var mainMethodDeclaration = SyntaxFactory
				.MethodDeclaration(sutType.GetSyntax(), methodSymbol.Name)
				.WithModifiers(
					SyntaxFactory.TokenList(
						methodSymbol
							.DeclaredAccessibility.ToSyntaxKinds()
							.Concat([SyntaxKind.PartialKeyword])
							.Select(SyntaxFactory.Token)
					)
				)
				.WithBody(
					SyntaxFactory.Block(
						SyntaxFactory.ReturnStatement(
							SyntaxFactory
								.ObjectCreationExpression(sutType.GetSyntax())
								.WithArgumentList(SyntaxFactory.ArgumentList())
						)
					)
				);

			var namespaceNode = SyntaxFactory
				.NamespaceDeclaration(
					SyntaxFactory.IdentifierName(methodSymbol.ContainingNamespace.ToDisplayString())
				)
				.WithLeadingTrivia(
					SyntaxFactory.SyntaxTrivia(
						SyntaxKind.SingleLineCommentTrivia,
						"// <auto-generated />"
					)
				)
				.WithMembers(
					SyntaxFactory.List<MemberDeclarationSyntax>(
						[
							partialDeclarationSyntax.WithMembers(
								SyntaxFactory.List<MemberDeclarationSyntax>([mainMethodDeclaration])
							)
						]
					)
				);
			var source = namespaceNode.NormalizeWhitespace("\t", "\n").ToFullString();
			context.AddSource(
				$"{methodSymbol.ContainingNamespace}_{methodSymbol.ContainingType}_{methodSymbol.Name}_Base__.g.cs",
				source
			);
		}
	}

	private static bool IsMatchingAttribute(SyntaxNode node, CancellationToken token)
	{
		if (node is not AttributeSyntax attribute)
			return false;

		return attribute.Name switch
		{
			SimpleNameSyntax sns => sns.Identifier.Text is AttributeName,
			QualifiedNameSyntax qns => qns.Right.Identifier.Text is AttributeName,
			_ => false
		};
	}

	private static IMethodSymbol? Transform(GeneratorSyntaxContext context, CancellationToken token)
	{
		if (context.Node is not AttributeSyntax attribute)
			return null;

		var parentSymbol = attribute.Parent?.Parent;

		if (parentSymbol is not MethodDeclarationSyntax methodDeclarationSyntax)
			return null;

		return context.SemanticModel.GetDeclaredSymbol(methodDeclarationSyntax, token);
	}
}
